#!/usr/bin/env python

# from __future__ import print_function

import roslib

roslib.load_manifest('exercise3')
import math
import sys
import rospy
from nav_msgs.msg import OccupancyGrid
import tf2_ros
import numpy as np
from geometry_msgs.msg import Point, Twist
from tf2_geometry_msgs.tf2_geometry_msgs import PoseStamped
from actionlib import SimpleActionClient
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from constants import ACTION_CLIENT_STATUSES


class MapGoals:

    def map_callback(self, data):
        size_x = data.info.width
        size_y = data.info.height
        self.cv_map = np.zeros(shape=(size_y, size_x))

        if size_x < 3 or size_y < 3:
            print("Map size is only x: {}, y: {}. Not running map to image conversion".format(size_x, size_y))

        rows, columns = self.cv_map.shape

        if rows != size_y and columns != size_x:
            self.cv_map = np.array([size_y, size_x])

        self.map_resolution = data.info.resolution
        self.map_transform = data.info.origin

        grid = np.flip(np.reshape(data.data, (size_y, size_x)), 0)

        for i in range(size_y):
            for j in range(size_x):
                if grid[i][j] == -1:
                    self.cv_map[i][j] = 127
                elif grid[i][j] == 100:
                    self.cv_map[i][j] = 0
                elif grid[i][j] == 0:
                    self.cv_map[i][j] = 255
                else:
                    print('Error at i:' + str(grid[i][j]))


        p = Point(5.0, 2.0, 0.0)
        print("Requesting initial goal with: {}", p)
        self.goal_request_pub.publish(p)


    def transform_point(self, point):
        _, size_y = self.cv_map.shape
        return Point(point.x * self.map_resolution + self.map_transform.position.x,
                  (size_y - point.y) * self.map_resolution + self.map_transform.position.y, 0)

    def point_2_base_goal(self, point):
        goal = PoseStamped()
        goal.header.frame_id = "map"
        goal.pose.orientation.w = 1
        goal.pose.position = point
        goal.header.stamp = rospy.Time(0)
        move_base_goal = MoveBaseGoal()
        move_base_goal.target_pose = goal
        return move_base_goal

    def rotate(self, speed, angle, clockwise=True):
        vel_msg = Twist()

        # Converting from angles to radians
        angular_speed = speed * 2 * math.pi / 360
        relative_angle = angle * 2 * math.pi / 360

        # We wont use linear components
        vel_msg.linear.x = 0
        vel_msg.linear.y = 0
        vel_msg.linear.z = 0
        vel_msg.angular.x = 0
        vel_msg.angular.y = 0

        if clockwise:
            vel_msg.angular.z = -abs(angular_speed)
        else:
            vel_msg.angular.z = abs(angular_speed)

        # Setting the current time for distance calculus
        t0 = rospy.Time.now().to_sec()
        current_angle = 0

        while (current_angle < relative_angle):
            self.velocity_publisher.publish(vel_msg)
            t1 = rospy.Time.now().to_sec()
            current_angle = angular_speed * (t1 - t0)

        vel_msg.angular.z = 0
        self.velocity_publisher.publish(vel_msg)
        rospy.spin()



    def goal_callback(self, point):
        transformed =self.transform_point(point)
        print("Transofrming point {} -> {}".format(point, transformed))

        # move_base_goal = self.point_2_base_goal(transformed)
        # self.action_client.send_goal(move_base_goal)
        # self.action_client.wait_for_result(rospy.Duration(60))
        # print("Action result: " + ACTION_CLIENT_STATUSES[self.action_client.get_state()])

        rotate(self.velocity_publisher, 15, 360)
        self.goal_request_pub.publish(point)

    def __init__(self):
        rospy.init_node('map_goals')

        self.action_client = SimpleActionClient("move_base", MoveBaseAction)
        self.action_client.wait_for_server()

        self.cv_map = None
        self.map_transform = None
        self.tf2_buffer = tf2_ros.Buffer()
        self.tf2_listener = tf2_ros.TransformListener(self.tf2_buffer)
        self.map_resolution = 0
        self.goal_pub = rospy.Publisher("goal", PoseStamped, queue_size=10)
        self.goal_request_pub = rospy.Publisher("goal/request", Point, queue_size=10)
        self.goal_response_sub = rospy.Subscriber("goal/response", Point, self.goal_callback)
        self.map_sub = rospy.Subscriber("map", OccupancyGrid, self.map_callback)
        self.velocity_publisher = rospy.Publisher('cmd_vel', Twist, queue_size=10)


def main(args):
    _ = MapGoals()
    try:
        rospy.spin()
    except KeyboardInterrupt:
        print("Shutting down")


if __name__ == '__main__':
    main(sys.argv)
